#!/usr/bin/env node
/*/---------------------------------------------------------/*/
/*/ Craydent LLC deploy-v0.3.4                              /*/
/*/ Copyright 2011 (http://craydent.com/about)              /*/
/*/ Dual licensed under the MIT or GPL Version 2 licenses.  /*/
/*/ (http://craydent.com/license)                           /*/
/*/---------------------------------------------------------/*/
/*/---------------------------------------------------------/*/
/* deploy_server params
	0=>interpreter/node command (not used)
	1=>node file being executed (not used)
	2=>env tier
	3=>socket port
	4=>http port
	5=>http auth username
	6=>http auth password
	7=>ssh key location or 'create'
	8=>email
	9=>git url
	10=>project name
	11=>yes/no to add webhooks
	12=>yes/no if the ssh key is already registered in git
	13=>the domain pointing to this server
	14=>git username
	15=>git password


actionable commands after initialization
	0=>interpreter/node command (not used)
	1=>node file being executed (not used)

add
 	2=>add command
	3=>git address[ssh url]
	4=>project name[default:git repo name]
	5=>create_webhooks[yes,no]
	6=>create_deploy_key[yes,no]
	7=>git username
	8=>git password
	9=>ssh key name[default:master_id_rsa]
restart
	3=>project name
backup
	3=>project name
build
	3=>project name
npminstall
	3=>project name
pull
	3=>project name
pullrestart
	3=>project name
pullsync
	3=>project name
restart
	3=>project name
start
	3=>project name
stop
	3=>project name
sync
	3=>project name

 */
var $c = require('craydent/noConflict');

$c.catchAll(function(err){
	console.log(err);
	process.exit();
});

require('shelljs/global');
const readline = require('readline');
const fs = require('fs');
const git = require('../git_actions');

const BASE_PATH = "/var/craydent/", CONFIG_PATH = BASE_PATH + "config/craydent-deploy/",
	NODE_PATH = BASE_PATH + "nodejs/craydent-deploy/", PROJECT_PATH = BASE_PATH + "nodejs/craydent-deploy/",
	GIT_PATH = BASE_PATH + "git/", LOG_BASE_PATH = BASE_PATH + "log/", LOG_PATH = LOG_BASE_PATH + "craydent-deploy/",
	KEY_PATH = BASE_PATH + "key/", CPROXY_PATH = '/var/craydent/config/craydent-proxy/pconfig.json',
	MASTER_KEY = 'master_id_rsa';


const INIT_ENV_NAME = 2, INIT_SOCKET_PORT = 3, INIT_HTTP_PORT = 4,
	INIT_HTTP_USERNAME = 5, INIT_HTTP_PASSWORD = 6, INIT_SSH_KEY = 7,
	INIT_EMAIL = 8, INIT_GIT_URL = 9, INIT_PROJECT_NAME = 10,
	INIT_WEBHOOKS = 11, INIT_GIT_SSHKEY = 12, INIT_FQDN = 13,
	INIT_GIT_USER = 14, INIT_GIT_PASSWORD = 15;

const ADD_GIT_URL = 3, ADD_PROJECT_NAME = 4, ADD_WEBHOOKS = 5,
	ADD_GIT_SSHKEY = 6, ADD_GIT_USER = 7, ADD_GIT_PASSWORD = 8,
	ADD_SSHKEY_NAME = 9;

const COMMAND = 2, PROJECT_NAME = 3;

const yes = {yes: 1, y: 1};
const no = {no: 1, n: 1};

var apps = [{
	"name": "craydent-deploy",
	"servers": ["index.js"],
	"logfile": [LOG_PATH + "index.log"],
	"size":{},
	"fd":{},
	"www": "",
	"nodejs":"",
	"webdir":"",
	"email":""
}];

const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout
});
const run = $c.yieldable(exec);
const question = $c.yieldable(rl.question, rl);
const fsstat = $c.yieldable(fs.stat, fs);
const fswrite = $c.yieldable(fs.writeFile, fs);
const fsread = $c.yieldable(fs.readFile, fs);

var nodeconfig = $c.include(CONFIG_PATH + 'nodeconfig');

if (process.argv[COMMAND] == "version" || process.argv[COMMAND] == "--version" || process.argv[COMMAND] == "-v") {
	console.log(require('../package.json').version);
	return process.exit();
}
if (process.argv[COMMAND] == 'reset') {
	return $c.syncroit(function*() {
		yield run(__dirname + "/../shell_scripts/reset_script.sh \"craydent-deploy\" \"index.js\" " + __dirname.replace('bin','') + ";");
		var status = false;
		try {
			status = (yield fsstat(CPROXY_PATH))[1];
			status && (yield run(__dirname + "/../shell_scripts/rm_routes_script.sh \"" + FQDN.replace(/https?:\/\/(.*?)(\/|\?|#|:|$).*/,'$1') + "\";"));
		} catch (e) { }
		console.log('Complete');
		process.exit();
	});
}
if (process.argv[COMMAND] == 'uninstall') {
	return $c.syncroit(function*() {
		yield run(__dirname + "/../shell_scripts/deploy_script.sh \"craydent-deploy\" \"stop\" \"\" \"\" \"\" \"index.js\"");
		yield run(__dirname + "/../shell_scripts/reset_script.sh \"craydent-deploy\" \"index.js\" " + __dirname.replace('bin','') + ";");
		var status = false;
		try {
			status = (yield fsstat(CPROXY_PATH))[1];
			status && FQDN && (yield run(__dirname + "/../shell_scripts/rm_routes_script.sh '" + FQDN.replace(/https?:\/\/(.*?)(\/|\?|#|:|$).*/,'$1') + "';"));
		} catch (e) { }
		yield run("npm uninstall -g " + require('../package.json').name + ";");
		console.log('Complete');
		process.exit();
	});
}
if(nodeconfig) {
	return $c.syncroit(function*(){
		var action = process.argv[COMMAND];
		if (!action) { // no action
			yield run(__dirname + "/../shell_scripts/node_script.sh \"craydent-deploy\" \"index.js\";");
		} else {
			apps = $c.include(CONFIG_PATH + "craydent_deploy_config.json", true);
			if (action == "add") {
				var bname = yield git_script(
					process.argv[ADD_GIT_URL],
					process.argv[ADD_PROJECT_NAME],
					global.FQDN,
					process.argv[ADD_WEBHOOKS],
					process.argv[ADD_GIT_SSHKEY],
					process.argv[ADD_GIT_USER],
					process.argv[ADD_GIT_PASSWORD],
					process.argv[ADD_SSHKEY_NAME],global.EMAIL);

				//yield run("echo \"" + $c.replace_all(JSON.stringify(apps),'"','\\""') + "\" > " + CONFIG_PATH + "craydent_deploy_config.json;");
				yield fswrite(CONFIG_PATH + "craydent_deploy_config.json", JSON.stringify(apps, null, 2));
				var appobj = $c.where(apps,{name:bname})[0];
				if (appobj) {
					var npath = BASE_PATH + "nodejs/" + bname;
					console.log('creating directory: ' + npath);
					yield run("mkdir -p " + npath + ";");
					console.log('copying git path ' + GIT_PATH + bname + "/" + (appobj.nodejs || "") + " to " + npath);
					yield run("cp -r " + GIT_PATH + bname + "/" + (appobj.nodejs || "") + "* " + npath + ";");
					console.log('building ' + bname);
					yield run(__dirname + "/../shell_scripts/deploy_script.sh \"" + bname + "\" \"build\" " + " " + (appobj.www || "''") +
						" " + (appobj.nodejs || "''") +
						" " + (appobj.webdir || "''") +
						" '" + appobj.servers.join(" ") + "'" +
						" '" + (global.ENV || "prod") + "'" + ";");

					var pconfig = $c.include(CPROXY_PATH,true);
					if (pconfig) {
						var p = $c.include(GIT_PATH + bname + '/package.json');
						p = JSON.parseAdvanced(p,null,null,GIT_PATH + bname);

						var routes = $c.getProperty(p, 'cproxy.routes');
						if (routes) {
							console.log('adding proxy routes');
							for (var domain in routes) {
								if (!routes.hasOwnProperty(domain)) { continue; }
								pconfig.routes[domain] = pconfig.routes[domain] || [];
								$c.upsert(pconfig.routes[domain], routes[domain], "name");
							}
							yield fswrite(CPROXY_PATH, JSON.stringify(pconfig, null, 2));
						}
					}

				}

			} else {
				var project = process.argv[PROJECT_NAME] || (yield question('What project do you want to ' + action + '? (type \'all\' to perform on all projects): '));
				while (!project) {
					project = (yield question('What project do you want to ' + action + '? (type \'all\' to perform on all projects): '));
				}

				var projects = $c.delete(apps, {name: project});
				if (project == "all") {
					projects = $c.delete(apps,{name:{"$ne":"craydent-deploy"}},false);
				}
				if (!projects.length) {
					if (project == "all") { console.log("There are no projects being tracked."); return process.exit(); }
					console.log("Can not find " + project + ".");
					return process.exit();
				}
				var arr = [];
				if (action == "rm") {
					var answer = yield question('Are you sure you want to remove '+(projects.length > 1 ? "theses " + projects.length + " projects" : "this project")+' and all of its files?  This action can not be undone (type \'delete\' to confirm): ');
					if (answer != "delete") {
						console.log("Remove cancelled");
						return process.exit();
					}
					var appobj;
					for (var i = 0, len = projects.length; i < len; i++) {
						appobj = projects[i];
						//if (appobj.name == "craydent-deploy" && process.argv[PROJECT_NAME] != "craydent-deploy") { continue; }
						yield run(__dirname + "/../shell_scripts/deploy_script.sh \"" + appobj.name + "\" \"backup\" " + " " + (appobj.www || "''") +
							" " + (appobj.nodejs || "''") +
							" " + (appobj.webdir || "''") +
							" '" + appobj.servers.join(" ") + "'" +
							" '" + (global.ENV || "prod") + "'" + ";");
						yield run(__dirname + "/../shell_scripts/deploy_script.sh \"" + appobj.name + "\" \"stop\" " + " " + (appobj.www || "''") +
							" " + (appobj.nodejs || "''") +
							" " + (appobj.webdir || "''") +
							" '" + appobj.servers.join(" ") + "'" +
							" '" + (global.ENV || "prod") + "'" + ";");
						var pkg = $c.include(GIT_PATH + appobj.name + '/package.json');
						if (pkg) {
							console.log('removing proxy routes');
							pkg = JSON.parseAdvanced(pkg,null,null,GIT_PATH + appobj.name);
							var routes = $c.getProperty(pkg, 'cproxy.routes');
							if (routes) { arr.push(removeRoutes(routes)); }
						}
						arr.push(run(__dirname + "/../shell_scripts/delete_project.sh \"" + appobj.name + "\""));

					}
					yield fswrite(CONFIG_PATH + "craydent_deploy_config.json", JSON.stringify(apps, null, 2));
				} else {
					for (var i = 0, len = projects.length; i < len; i++) {
						appobj = projects[i];
						arr.push(run(__dirname + "/../shell_scripts/deploy_script.sh \"" + appobj.name + "\" \"" + action + "\" " + " " + (appobj.www || "''") +
							" " + (appobj.nodejs || "''") +
							" " + (appobj.webdir || "''") +
							" '" + appobj.servers.join(" ") + "'" +
							" '" + (global.ENV || "prod") + "'" + ";"));
					}
				}
				yield $c.parallelEach(arr);
			}
			console.log('Completed');
		}
		process.exit();
	});
}

function deploy_script (buildnames, sport, hport, authu, authp) {
	return $c.syncroit(function*() {
		var pconfig = $c.include(CPROXY_PATH,true);
		for (var i = 0, len = buildnames.length; i < len; i++) {
			var buildname = buildnames[i];
			var p = $c.include(GIT_PATH + buildname + '/package.json');
			var server = p.main || "";
			yield run(PROJECT_PATH + 'shell_scripts/deploy_script.sh ' + buildname + ' pullrestart \'\' \'\' \'\' \'' + server + '\';');

			if (pconfig) {
				p = JSON.parseAdvanced(p,null,null,GIT_PATH + buildname);
				var routes = $c.getProperty(p, 'cproxy.routes') || {};
				for (var domain in routes) {
					if (!routes.hasOwnProperty(domain)) { continue; }
					pconfig.routes[domain] = pconfig.routes[domain] || [];
					$c.upsert(pconfig.routes[domain], routes[domain],"name");
				}
			}
		}
		if (pconfig) {
			var dconfig = $c.include(__dirname + '/../package.json') || {};
			var routes = $c.getProperty(dconfig, 'cproxy.routes') || {};
			for (var domain in routes) {
				if (!routes.hasOwnProperty(domain)) { continue; }
				pconfig.routes[domain] = pconfig.routes[domain] || [];
				$c.upsert(pconfig.routes[domain], routes[domain],"name");
			}
			yield fswrite(CPROXY_PATH, JSON.stringify(pconfig, null, 2));
		}
		yield run("nohup node " + NODE_PATH + "index.js " + sport + " " + hport + " '" + scuid + "' '" + authu + "' '" + authp + "' > " + LOG_PATH + "index.js.log 2>&1 &");
	});
}
function git_script(gitUrl, name, deploy_url, create_webhooks, create_deploy_key, gitUser, gitPassword, key_name, email) {
	var username =  String(require('child_process').execSync( "whoami", { encoding: 'utf8', timeout: 1000 } )).trim();
	key_name = key_name || MASTER_KEY;
	return $c.syncroit(function*() {
		var pconfig = $c.include(CPROXY_PATH,true);
		gitUrl = gitUrl || (yield question('What is the GitHub or BitBucket SSH url: '));
		var buildname = gitUrl.replace(/.*\/(.*)\.git/, '$1');
		buildname = name || (yield question('What do you want to call your project (' + buildname + '): ')) || buildname;
		var setupWebHooks = create_webhooks || (yield question('Set up Webhooks for continuous integration? (yes): ')) || "yes";
		var createDeployKey = create_deploy_key || (yield question('Do you want to add your ssh master key in Git? (yes): ')) || "yes";
		var url = "";
		if (setupWebHooks in yes || createDeployKey in yes) {
			url = deploy_url || (yield question('What URL will be running this instance of cdeploy? (ex: http://www.example.com:80): '));
		}
		var protocol = "http";

		var host, url_parts = gitUrl.match(/(.*):(.*)?\/(.*)\.git/);

		if ($c.startsWith(gitUrl, "http")) {
			url_parts = gitUrl.match(/https?:\/\/(?:.*?@)?(.*)?\/(.*)?\/(.*)?\.git.*/,"git@$1:$2/$3.git");
		}

		if ($c.startsWith(url, "http")) {
			var parts = url.split(':');
			protocol = parts[0] || protocol;
			global.HTTP_PORT = $c.strip(parts[2] || "", "/") || global.HTTP_PORT;
			host = $c.strip(parts[1], "/");
		}
		//var repo_owner = gitUrl.replace(/.*:(.*)?\/.*\.git/, '$1');
		//var project_name = gitUrl.replace(/.*:.*?\/(.*)\.git/, '$1');
		var repo_owner = url_parts[2];
		var project_name = url_parts[3];

		function loginRun(cb) {
			return $c.syncroit(function*() {
				gitUser = gitUser || (yield question('If you would like us to add the ssh to your git account, type your username (Enter): '));
				if (gitUser) {
					gitPassword = gitPassword || (yield hidden("Enter your password: "));
					yield cb();
				}
			});
		}

		if (createDeployKey in yes) {
			var cdk = function (){
				return $c.syncroit(function*() {
					var content = yield fsread(KEY_PATH + MASTER_KEY + ".pub", {encoding: 'utf8'});
					var results = yield git.createDeployKey({
						git_address: gitUrl,
						repo_owner: repo_owner,
						project_name: project_name,
						git_user: gitUser,
						git_password: gitPassword,
						key_name: key_name,
						content: content
					});
					if (!results) {
						console.log('Login Failed.');
						gitUser = "";
						gitPassword = "";
						return (yield loginRun(cdk));
					}
					return results;
				});
			};
			yield loginRun(cdk);
		}
		if (setupWebHooks in yes) {
			var cwh = function (){
				return $c.syncroit(function*() {
					var results = yield git.createWebhook({
						protocol: protocol,
						host: host,
						name: buildname,
						git_address: gitUrl,
						repo_owner: repo_owner,
						project_name: project_name,
						git_user: gitUser,
						git_password: gitPassword
					}, !!pconfig);
					if (!results) {
						console.log('Login Failed.');
						gitUser = "";
						gitPassword = "";
						return (yield loginRun(cwh));
					}
					return results;
				});
			};
			yield loginRun(cwh);
		}

		yield run("rm -rf " + GIT_PATH + buildname + ";");
		yield run("mkdir -p " + GIT_PATH + buildname + ";");
		yield run('chown -R ' + username + ' ' + BASE_PATH + ';');
		yield run('ssh-agent bash -c "ssh-add ' + KEY_PATH + key_name + '; git clone ' + gitUrl + ' ' + GIT_PATH + buildname + '";');
		yield run('chown -R ' + username + ' ' + BASE_PATH + ';');


		var pkg = $c.include(GIT_PATH + buildname + "/package.json");
		var server = pkg.main || "index.js";

		apps.push({
			"name": buildname,
			"servers": [server],
			"logfile": [LOG_BASE_PATH + server + ".log"],
			"size": {},
			"fd": {},
			"www": "",
			"nodejs": "",
			"webdir": "",
			"email": email
		});
		return buildname;
	});
}
function ssh_script() {
	return $c.syncroit(function*() {
		var status, answer,ssh_file;
		try {
			status = (yield fsstat("~/.ssh/id_rsa.pub"))[1];
		} catch (e) { }
		if (status) { // ssh key found
			answer = (yield question('Found a ssh key "id_rsa.pub".  Do you want to use this? (yes): ')) || "yes";
			if (answer in yes) {
				return "~/.ssh/id_rsa.pub";
			}
		}
		// ssh key not found or said not to use the default ssh id_rsa
		try {
			status = (yield fsstat(ssh_file = KEY_PATH + "master_id_rsa.pub"))[1];
		} catch (e) { }
		if (status) { // ssh key found
			answer = (yield question('Found deploy ssh master key.  Do you want to use this? (yes): ')) || "yes";
			if (answer in yes) {
				return ssh_file;
			}
		}
		ssh_file = yield question('Enter to create a key or type the full path to the ssh key? (Enter): ');

		return ssh_file;

	});
}
function updateRoutes(values) {
	return $c.syncroit(function*() {
		var pconfig = $c.include(CPROXY_PATH,true);
		var dconfig;
		if (pconfig && (dconfig = $c.include(__dirname + '/../package.json'))) {
			var routes = $c.getProperty(JSON.parseAdvanced(dconfig, null, values), 'cproxy.routes') || {};
			for (var domain in routes) {
				if (!routes.hasOwnProperty(domain)) { continue; }
				pconfig.routes[domain] = pconfig.routes[domain] || [];
				$c.upsert(pconfig.routes[domain], routes[domain],"name");
			}
			yield fswrite(CPROXY_PATH, JSON.stringify(pconfig, null, 2));
		}
	});
}
function removeRoutes(routes) {
	return $c.syncroit(function*() {
		var pconfig = $c.include(CPROXY_PATH,true);
		if (pconfig) {
			for (var domain in routes) {
				if (!routes.hasOwnProperty(domain) || !pconfig.routes[domain]) { continue; }
				var mappings = routes[domain];
				for (var i = 0, len = mappings.length; i < len; i++) {
					var index = $c.indexOfAlt(pconfig.routes[domain], mappings[i], function(item, val){
						return item.name == val.name;
					});
					console.log(index,mappings[i].name);
					if (~index) { $c.removeAt(pconfig.routes[domain], index); }
				}
				if (!pconfig.routes[domain].length) {
					delete pconfig.routes[domain];
				}
			}
			yield fswrite(CPROXY_PATH, JSON.stringify(pconfig, null, 2));
		}
	});
}
function writeNodeConfig(sport,hport,scuid,authu,authp,email,env,fqdn){
	return $c.syncroit(function*() {
		var ncontent = "global.SOCKET_PORT = " + sport +
			";\nglobal.HTTP_PORT = " + hport +
			";\nglobal.SAC = '" + scuid + "';" +
			"\nglobal.HTTP_AUTH_USERNAME = '" + (authu || "admin") + "';" +
			"\nglobal.HTTP_AUTH_PASSWORD = '" + (authp || "admin") + "';" +
			"\nglobal.EMAIL = '" + (email || "" ) + "';" +
			"\nglobal.ENV = '" + (env || "prod") + "';" +
			"\nglobal.FQDN = '" + (fqdn || "") + "';";
		return yield run("echo \"" + ncontent + "\" > " + CONFIG_PATH + "nodeconfig.js;");
	});
}
$c.syncroit(function*() {
	var ssh_file;

	//--------environment related
	var fqdn = global.FQDN = process.argv[INIT_FQDN] || (yield question('What URL will be running this instance of cdeploy? (ex: http://www.example.com:80): '));
	var env = global.ENV = process.argv[INIT_ENV_NAME] || (yield question('What tier/environment is this server? (PROD): ')) || "PROD";
	var sport = global.SOCKET_PORT = process.argv[INIT_SOCKET_PORT] || (yield question('What socket port do you want to use? (4900): ')) || 4900;
	var hport = global.HTTP_PORT = process.argv[INIT_HTTP_PORT] || (yield question('What server port do you want to use? (4800): ')) || 4800;
	var authu = global.HTTP_AUTH_USERNAME = process.argv[INIT_HTTP_USERNAME] || (yield question('What HTTP Auth username do you want to use? (admin): ')) || 'admin';
	var authp = global.HTTP_AUTH_PASSWORD = process.argv[INIT_HTTP_PASSWORD] || (yield question('What HTTP Auth password do you want to use? (admin): ')) || 'admin';
	var scuid = global.SAC = $c.cuid();
	var pconfig = $c.include(CPROXY_PATH, true);

	//--------end environment related

	//--------ssh related
	if (!process.argv[INIT_SSH_KEY]) {
		ssh_file = yield ssh_script();
	} else {
		if (process.argv[INIT_SSH_KEY] != "create") {
			ssh_file = process.argv[INIT_SSH_KEY];
		}
	}
	//--------end ssh related

	//--------dir related
	var username = String(require('child_process').execSync("whoami", {encoding: 'utf8', timeout: 1000})).trim();
	var params = yield run(__dirname + "/../shell_scripts/create_dirs.sh \"/var\" \"" + username + "\""); // params [code,output,message]
	yield run('chown -R ' + username + ' ' + BASE_PATH + ';');
	//--------end dir related

	//--------notifications
	var email = global.EMAIL = process.argv[INIT_EMAIL] || (yield question('Email for notifications. (Enter): '));
	//--------end notifications

	//--------ssh copy/create
	if (ssh_file) {
		if (ssh_file != KEY_PATH + MASTER_KEY + ".pub") {
			yield run('cp ' + ssh_file + ' ' + KEY_PATH + MASTER_KEY + '.pub;cp ' + ssh_file.replace('.pub', '') + ' ' + KEY_PATH + MASTER_KEY + ';');
		}
	} else {
		var status = false;
		try {
			status = (yield fsstat(KEY_PATH + MASTER_KEY))[1];
			if (status) {
				console.log(KEY_PATH + MASTER_KEY + ' already exists.');
				var ow = yield question('Overwrite (y/n)? ');
				if (ow in yes) { run('rm ' + KEY_PATH + MASTER_KEY + '.pub;rm ' + KEY_PATH + MASTER_KEY ); }
			}
		} catch (e) { }
		yield run('ssh-keygen -t rsa -C "' + email + '" -N "" -f ' + KEY_PATH + MASTER_KEY + ';');
	}
	yield run('chown -R ' + username + ' ' + BASE_PATH + ';chmod 600 ' + KEY_PATH + MASTER_KEY);
	//--------end ssh copy/create

	var buildnames = [];
	//--------git related
	if (process.argv[INIT_GIT_URL] || $c.isNull(process.argv[INIT_GIT_URL]) && process.argv.length < 3) {
		var skip = yield question('Let\'s create a project or enter \'skip\' to do this later: ');
		while (skip != 'skip' && !(skip in no)) {
			buildnames.push(yield git_script(
				process.argv[INIT_GIT_URL],
				process.argv[INIT_PROJECT_NAME],
				fqdn,
				process.argv[INIT_WEBHOOKS],
				process.argv[INIT_GIT_SSHKEY],
				process.argv[INIT_GIT_USER],
				process.argv[INIT_GIT_PASSWORD],null,global.EMAIL));

			skip = (yield question('Add another project? (no): ')) || "no";
		}
	}
	//--------end git related

	//--------move app and start deploy service
	yield run("mkdir -p " + PROJECT_PATH + ";");
	yield run("mkdir -p " + LOG_PATH + ";");
	yield run("mkdir -p " + CONFIG_PATH + ";");
	yield run("cp -r " + __dirname.replace('bin','') + "* " + PROJECT_PATH);
	yield run('chown -R ' + username + ' ' + BASE_PATH + ';');
	yield writeNodeConfig(sport,hport,scuid,authu,authp,email,env,fqdn);
	//yield run("echo \"" + $c.replace_all(JSON.stringify(apps),'"','\\""') + "\" > " + CONFIG_PATH + "craydent_deploy_config.json;");
	yield fswrite(CONFIG_PATH + "craydent_deploy_config.json", JSON.stringify(apps, null, 2));

	if (buildnames.length) {
		yield deploy_script(buildnames,sport,hport,authu,authp);
	}
	yield updateRoutes({domain:fqdn.replace(/https?:\/\/(.*?)(\/|\?|#|:|$).*/,'$1'),env:env,socket_port:sport,http_port:hport,username:authu,password:authp,cuid:scuid});
	yield run("nohup node " + NODE_PATH + "index.js " + sport + " " + hport + " '" + scuid + "' '" + authu + "' '" + authp + "' > " + LOG_PATH + "index.js.log 2>&1 &");
	//--------end move app and start deploy service

	console.log('Completed');
	rl.close();
	process.exit();
});
function hidden(query) {
	return new Promise(function(res) {
		var fn = function (char) {
			char = char + "";
			switch (char) {
				case "\n":
				case "\r":
				case "\u0004":
					rl.pause();
					break;
				default:
					process.stdout.write("\033[2K\033[200D" + query + Array(rl.line.length + 1).join("*"));
					break;
			}
		};
		process.stdin.on("data", fn);

		rl.question(query, function (value) {
			rl.history = rl.history.slice(1);
			res(value);
			process.stdin.removeListener("data",fn);
		});
	});
}